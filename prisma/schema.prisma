generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String   @id @default(uuid())
  email             String   @unique
  name              String?
  emailVerified     DateTime?
  image             String?
  profileImage      String?  // Professional profile photo URL
  password          String?  // For credentials login
  
  // User role - can be multiple
  roles             String[] @default(["founder"]) // ["founder", "service_provider"]
  
  // Founder-specific fields
  founderJourney    String?  // Founder journey stage from onboarding
  title             String?
  bio               String?
  skills            String?  // Store as JSON string or comma-separated
  experience        String?
  lookingFor        String?
  projectLinks      String?  // Store as JSON string
  quizCompleted     Boolean  @default(false)
  quizScores        Json?    // Store { openness: 4.2, conscientiousness: 3.8, ... }
  personalityProfile Json?   // Calculated compatibility profile
  
  // Additional profile fields for filtering
  industry          String?  // Tech, Fintech, Healthcare, etc.
  stage             String?  // Idea, MVP, Early Revenue, Scaling
  location          String?  // City/region
  remoteOk          Boolean  @default(true)
  timeCommitment    String?  // Full-time, Part-time, Flexible
  fundingStatus     String?  // Bootstrapped, Seeking, Funded
  companyGoals      String?  // Lifestyle, Scale, Unicorn
  workStyle         String?  // Structured, Flexible, Fast-paced
  isTechnical       Boolean?  // Can build product without outside assistance
  
  // Service Provider fields
  serviceTypes      String[] @default([]) // ["development", "design", "marketing", "legal"]
  portfolio         String?  // JSON string of portfolio items
  hourlyRate        Int?     // Rate in USD
  availability      String?  // "immediate", "within_week", "within_month"
  
  // Filter preferences for discovery
  filterPreferences Json?    // Store discovery filter preferences
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  // NextAuth relationships
  accounts          Account[]
  sessions          Session[]
  
  // Matching relationships
  sentMatches       Match[] @relation("MatchSender")
  receivedMatches   Match[] @relation("MatchReceiver")
  
  // Project relationships
  projects          Project[] @relation("ProjectOwner")
  projectMatches    ProjectMatch[] @relation("ServiceProvider")
  
  // Community relationships
  forumPosts        ForumPost[] @relation("PostAuthor")
  forumComments     ForumComment[] @relation("CommentAuthor")
  postLikes         PostLike[]
  commentLikes      CommentLike[]
  
  @@map("users")
}

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Match {
  id         String    @id @default(uuid())
  senderId   String
  receiverId String
  liked      Boolean   // true = liked, false = passed
  matched    Boolean   @default(false) // true when both users like each other
  createdAt  DateTime  @default(now())
  
  sender     User @relation("MatchSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver   User @relation("MatchReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  
  @@unique([senderId, receiverId])
  @@map("matches")
}

model Project {
  id              String    @id @default(uuid())
  title           String
  description     String
  ownerId         String
  
  // Project requirements
  serviceType     String    // "development", "design", "marketing", "legal"
  budget          Int?      // Budget in USD
  timeline        String?   // "asap", "within_week", "within_month", "flexible"
  complexity      String?   // "simple", "medium", "complex"
  
  // Project details
  requirements    String?   // Detailed requirements
  techStack       String[]  @default([]) // For development projects
  deliverables    String?   // JSON string of expected deliverables
  
  // Status
  status          String    @default("open") // "open", "in_progress", "completed", "cancelled"
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // Relationships
  owner           User @relation("ProjectOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  matches         ProjectMatch[]
  
  @@map("projects")
}

model ProjectMatch {
  id                String    @id @default(uuid())
  projectId         String
  serviceProviderId String
  status            String    @default("pending") // "pending", "accepted", "declined", "completed"
  proposal          String?   // Service provider's proposal
  proposedRate      Int?      // Proposed hourly rate
  proposedTimeline  String?   // Proposed timeline
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  // Relationships
  project           Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  serviceProvider   User @relation("ServiceProvider", fields: [serviceProviderId], references: [id], onDelete: Cascade)
  
  @@unique([projectId, serviceProviderId])
  @@map("project_matches")
}

model ForumCategory {
  id          String    @id @default(uuid())
  name        String    @unique
  slug        String    @unique
  description String?
  color       String    @default("#6366f1") // Hex color for category
  icon        String?   // Icon name for category
  order       Int       @default(0) // Display order
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relationships
  posts       ForumPost[]
  
  @@map("forum_categories")
}

model ForumPost {
  id            String    @id @default(uuid())
  title         String
  content       String    // Main post content
  slug          String    @unique // URL-friendly slug
  authorId      String
  categoryId    String
  
  // Post metadata
  isPinned      Boolean   @default(false)
  isLocked      Boolean   @default(false)
  views         Int       @default(0)
  
  // Engagement
  likesCount    Int       @default(0)
  commentsCount Int       @default(0)
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Relationships
  author        User @relation("PostAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  category      ForumCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  comments      ForumComment[]
  likes         PostLike[]
  
  @@map("forum_posts")
}

model ForumComment {
  id        String    @id @default(uuid())
  content   String
  authorId  String
  postId    String
  parentId  String?   // For nested replies
  
  // Engagement
  likesCount Int      @default(0)
  
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  
  // Relationships
  author    User @relation("CommentAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  post      ForumPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  parent    ForumComment? @relation("CommentThread", fields: [parentId], references: [id])
  replies   ForumComment[] @relation("CommentThread")
  likes     CommentLike[]
  
  @@map("forum_comments")
}

model PostLike {
  id     String @id @default(uuid())
  userId String
  postId String
  
  createdAt DateTime @default(now())
  
  // Relationships
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post ForumPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  @@unique([userId, postId])
  @@map("post_likes")
}

model CommentLike {
  id        String @id @default(uuid())
  userId    String
  commentId String
  
  createdAt DateTime @default(now())
  
  // Relationships
  user    User @relation(fields: [userId], references: [id], onDelete: Cascade)
  comment ForumComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  
  @@unique([userId, commentId])
  @@map("comment_likes")
}